#include "ST7565.h"
#include "osObjects.h"   
#define ST7565_STARTBYTES 0

const uint8_t pagemap[] = { 7, 6, 5, 4, 3, 2, 1, 0 };

// the memory buffer for the LCD
uint8_t st7565_buffer[1024] = {
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

// reduces how much is refreshed, which speeds it up!
// originally derived from Steve Evans/JCW's mod but cleaned up and
// optimized
#define enablePartialUpdate 	1
#define tradeSizeForSpeed 		1
	
#ifdef enablePartialUpdate
static uint8_t xUpdateMin, xUpdateMax, yUpdateMin, yUpdateMax;
#endif

#define PAGE_FLIP 0x7

const uint8_t rotate180 = 0x00;

void ST7565_command(uint8_t c) {
	int j = 8;
	
	LCD_SPI_SELECT_GPIO_PORT->BRR = LCD_SPI_SELECT_PIN;
	LCD_A0_GPIO_PORT->BRR = LCD_A0_PIN;
	do{
  	if(c&0x80){
    	LCD_SPI_MOSI_GPIO_PORT->BSRR = LCD_SPI_MOSI_PIN;
		}else{
    	LCD_SPI_MOSI_GPIO_PORT->BRR = LCD_SPI_MOSI_PIN;
		}
		LCD_SPI_SCK_GPIO_PORT->BRR = LCD_SPI_SCK_PIN;
		LCD_SPI_SCK_GPIO_PORT->BSRR = LCD_SPI_SCK_PIN;
  	--j;
    c<<=1;
	}while(j);
	LCD_SPI_SELECT_GPIO_PORT->BSRR = LCD_SPI_SELECT_PIN;
}

void ST7565_data(uint8_t c){
	int j = 8;
	
	LCD_SPI_SELECT_GPIO_PORT->BRR = LCD_SPI_SELECT_PIN;
	LCD_A0_GPIO_PORT->BSRR = LCD_A0_PIN;
	do{
  	if(c&0x80){
			LCD_SPI_MOSI_GPIO_PORT->BSRR = LCD_SPI_MOSI_PIN;
  	}else{
			LCD_SPI_MOSI_GPIO_PORT->BRR = LCD_SPI_MOSI_PIN;
		}
		LCD_SPI_SCK_GPIO_PORT->BRR = LCD_SPI_SCK_PIN;
		LCD_SPI_SCK_GPIO_PORT->BSRR = LCD_SPI_SCK_PIN;
  	--j;
    c<<=1;
	}while(j);
	LCD_SPI_SELECT_GPIO_PORT->BSRR = LCD_SPI_SELECT_PIN;
}

static void ST7565_updateBoundingBox(uint8_t xmin, uint8_t ymin, uint8_t xmax, uint8_t ymax) {
#ifdef enablePartialUpdate
  if (xmin < xUpdateMin) xUpdateMin = xmin;
  if (xmax > xUpdateMax) xUpdateMax = xmax;
  if (ymin < yUpdateMin) yUpdateMin = ymin;
  if (ymax > yUpdateMax) yUpdateMax = ymax;
#endif
}

void ST7565_drawbitmap(uint8_t x, uint8_t y, const uint8_t *bitmap, uint8_t w, uint8_t h, uint8_t color) {
  uint8_t i, j;
  for (j = 0; j < h; j++) {
    for (i = 0; i < w; i++ ) {
      if (bitmap[i + (j / 8) * w] & (1 << (j % 8))) {
        ST7565_my_setpixel(x + i, y + j, color);
      }
    }
  }

  ST7565_updateBoundingBox(x, y, x + w, y + h);
}
	
// bresenham's algorithm - thx wikpedia
void ST7565_drawline(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1, uint8_t color){
	uint8_t dx, dy;
	int8_t	err, ystep;
						
  uint8_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
    swap(x0, x1);
    swap(y0, y1);
  }

  // much faster to put the test here, since we've already sorted the points
  ST7565_updateBoundingBox(x0, y0, x1, y1);

  dx = x1 - x0;
  dy = abs(y1 - y0);

  err = dx / 2;

  if (y0 < y1) {
    ystep = 1;
  } else {
    ystep = -1;}

  for (; x0 <= x1; x0++) {
    if (steep) {
    	ST7565_my_setpixel(y0, x0, color);
    } else {
    	ST7565_my_setpixel(x0, y0, color);
    }
    err -= dy;
    if (err < 0) {
      y0 += ystep;
      err += dx;
    }
  }
}

// filled rectangle
void ST7565_fillrect(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1, uint8_t color) {
  uint8_t i, j;
	
  // stupidest version - just pixels - but fast with internal buffer!
  for (i = x0; i < x1; i++) {
    for (j = y0; j < y1; j++) {
      ST7565_my_setpixel(i, j, color);
    }
  }

  ST7565_updateBoundingBox(x0, y0, x1, y1);
}

// draw a rectangle
void ST7565_drawrect(uint8_t x, uint8_t y, uint8_t w, uint8_t h, uint8_t color) {
  uint8_t i;
  // stupidest version - just pixels - but fast with internal buffer!
  for (i = x; i < x + w; i++) {
		ST7565_my_setpixel(i, y, color);
		ST7565_my_setpixel(i, y + h - 1, color);
  }
	
  for (i = y; i < y + h; i++) {
		ST7565_my_setpixel(x, i, color);
		ST7565_my_setpixel(x + w - 1, i, color);
  }

  ST7565_updateBoundingBox(x, y, x + w, y + h);
}

// draw a circle outline
void ST7565_drawcircle(uint8_t x0, uint8_t y0, uint8_t r, uint8_t color){
	int8_t f = 1 - r;
  int8_t ddF_x = 1;
  int8_t ddF_y = -2 * r;
  int8_t x = 0;
  int8_t y = r;
	
	ST7565_updateBoundingBox(x0 - r, y0 - r, x0 + r, y0 + r);

  ST7565_my_setpixel(x0, y0+r, color);
  ST7565_my_setpixel(x0, y0-r, color);
  ST7565_my_setpixel(x0+r, y0, color);
  ST7565_my_setpixel(x0-r, y0, color);

  while (x < y) {
    if (f >= 0){
      y--;
      ddF_y += 2;
      f += ddF_y;
    }
    x++;
    ddF_x += 2;
    f += ddF_x;
  
    ST7565_my_setpixel(x0 + x, y0 + y, color);
    ST7565_my_setpixel(x0 - x, y0 + y, color);
    ST7565_my_setpixel(x0 + x, y0 - y, color);
    ST7565_my_setpixel(x0 - x, y0 - y, color);
    
    ST7565_my_setpixel(x0 + y, y0 + x, color);
    ST7565_my_setpixel(x0 - y, y0 + x, color);
    ST7565_my_setpixel(x0 + y, y0 - x, color);
    ST7565_my_setpixel(x0 - y, y0 - x, color); 
  }
}

void ST7565_fillcircle(uint8_t x0, uint8_t y0, uint8_t r, uint8_t color) {
  int8_t f = 1 - r;
  int8_t ddF_x = 1;
  int8_t ddF_y = -2 * r;
  int8_t x = 0;
  int8_t y = r;
  uint8_t i;
	
  ST7565_updateBoundingBox(x0-r, y0-r, x0+r, y0+r);
	
  for(i = y0 - r; i <= y0 + r; i++){
		ST7565_my_setpixel(x0, i, color);
  }

  while (x < y) {
    if (f >= 0) {
      y--;
      ddF_y += 2;
      f += ddF_y;
    }
    x++;
    ddF_x += 2;
    f += ddF_x;
  
    for (i = y0 - y; i <= y0 + y; i++) {
      ST7565_my_setpixel(x0 + x, i, color);
      ST7565_my_setpixel(x0 - x, i, color);
    } 
    for (i = y0 - x; i <= y0 + x; i++) {
      ST7565_my_setpixel(x0 + y, i, color);
      ST7565_my_setpixel(x0 - y, i, color);
    }    
  }
}

void ST7565_my_setpixel(uint8_t x, uint8_t y, uint8_t color) {
  if ((x >= LCDWIDTH) || (y >= LCDHEIGHT))
    return;
	
  // x is which column
  if (color) 
    st7565_buffer[x + (y / 8) * 128] |= (1 << (7 - (y % 8)));
  else
    st7565_buffer[x + (y / 8) * 128] &= ~(1 << (7 - (y % 8)));
}

// the most basic function, set a single pixel
void ST7565_setpixel(uint8_t x, uint8_t y, uint8_t color) {
  if ((x >= LCDWIDTH) || (y >= LCDHEIGHT))
    return;
	
  // x is which column
  if (color) 
    st7565_buffer[x + (y / 8) * 128] |= (1 << (7 - (y % 8)));
  else
    st7565_buffer[x + (y / 8) * 128] &= ~(1 << (7 - (y % 8)));
	
  ST7565_updateBoundingBox(x,y,x,y);
}

// the most basic function, get a single pixel
uint8_t ST7565_getpixel(uint8_t x, uint8_t y) {
  if ((x >= LCDWIDTH) || (y >= LCDHEIGHT))
    return 0;
	
  return (st7565_buffer[x + (y / 8) * 128] >> (7 - (y % 8))) & 0x1;  
}

void LCD_Init(uint8_t contrast){
	ST7565_SPI_Init();
  ST7565_init();
  ST7565_command(CMD_DISPLAY_ON);
  ST7565_command(CMD_SET_ALLPTS_NORMAL);
  ST7565_set_brightness(contrast);
	
	ST7565_clear_display();
}

void ST7565_SPI_Init(void){
	GPIO_InitTypeDef GPIO_InitStructure;
	
	/* GPIO clocks config */
  RCC_AHBPeriphClockCmd(LCD_SPI_SCK_GPIO_CLK | LCD_SPI_MOSI_GPIO_CLK | LCD_SPI_SELECT_GPIO_CLK | LCD_RESET_GPIO_CLK | LCD_A0_GPIO_CLK, ENABLE);
	
	/* CFG output mode */
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	
	/* PB.12 SELECT */
	GPIO_InitStructure.GPIO_Pin = LCD_SPI_SELECT_PIN;
	GPIO_Init(LCD_SPI_SELECT_GPIO_PORT, &GPIO_InitStructure);
	/* Deselect the LCD: SELECT high */
	GPIO_SetBits(LCD_SPI_SELECT_GPIO_PORT, LCD_SPI_SELECT_PIN);
	
	/* Configure LCD SCK */
	GPIO_InitStructure.GPIO_Pin = LCD_SPI_SCK_PIN;
	GPIO_Init(LCD_SPI_SCK_GPIO_PORT, &GPIO_InitStructure);
	
	/* Configure LCD MOSI */
	GPIO_InitStructure.GPIO_Pin = LCD_SPI_MOSI_PIN;
	GPIO_Init(LCD_SPI_MOSI_GPIO_PORT, &GPIO_InitStructure);

  /* Configure the LCD RESET pin */
	GPIO_InitStructure.GPIO_Pin = LCD_RESET_PIN;
  GPIO_Init(LCD_RESET_GPIO_PORT, &GPIO_InitStructure);
	
	/* Configure the LCD A0 pin */
	GPIO_InitStructure.GPIO_Pin = LCD_A0_PIN;
  GPIO_Init(LCD_A0_GPIO_PORT, &GPIO_InitStructure);
	
	/* Configure the LCD LED pin */
	GPIO_InitStructure.GPIO_Pin = LCD_LED_PIN;
  GPIO_Init(LCD_LED_GPIO_PORT, &GPIO_InitStructure);
	GPIO_SetBits(LCD_LED_GPIO_PORT, LCD_LED_PIN);
}

void ST7565_init(void){
  GPIO_ResetBits(LCD_SPI_SELECT_GPIO_PORT, LCD_SPI_SELECT_PIN);
	
  GPIO_ResetBits(LCD_RESET_GPIO_PORT, LCD_RESET_PIN);
  osDelay(500);
  GPIO_SetBits(LCD_RESET_GPIO_PORT, LCD_RESET_PIN);

  // LCD bias select
  ST7565_command(CMD_SET_BIAS_7);
  // ADC select
  ST7565_command(CMD_SET_ADC_NORMAL);
  // SHL select
  ST7565_command(CMD_SET_COM_NORMAL);
  // Initial display line
  ST7565_command(CMD_SET_DISP_START_LINE);

  // turn on voltage converter (VC=1, VR=0, VF=0)
  ST7565_command(CMD_SET_POWER_CONTROL | 0x4);
  // wait for 50% rising
  osDelay(50);

  // turn on voltage regulator (VC=1, VR=1, VF=0)
  ST7565_command(CMD_SET_POWER_CONTROL | 0x6);
  // wait >=50ms
  osDelay(50);

  // turn on voltage follower (VC=1, VR=1, VF=1)
  ST7565_command(CMD_SET_POWER_CONTROL | 0x7);
  // wait
  osDelay(10);
	
  // set lcd operating voltage (regulator resistor, ref voltage resistor)
  ST7565_command(CMD_SET_RESISTOR_RATIO | 0x6);
}

void ST7565_set_brightness(uint8_t val) {
	ST7565_command(CMD_SET_VOLUME_FIRST);
    ST7565_command(CMD_SET_VOLUME_SECOND | (val & 0x3f));
}

void ST7565_display(void) {
  uint8_t col, maxcol, p;

  for(p = 0; p < 8; p++) {
#ifdef enablePartialUpdate
    // check if this page is part of update
    if ( yUpdateMin >= ((p+1)*8) ) {
      continue;   // nope, skip it!
    }
    if (yUpdateMax < p*8) {
      break;
    }
#endif

		osDelay(1);
    ST7565_command(CMD_SET_PAGE | pagemap[p]);
    osDelay(1);


#ifdef enablePartialUpdate
    col = xUpdateMin;
    maxcol = xUpdateMax;
#else
    // start at the beginning of the row
    col = 0;
    maxcol = LCDWIDTH;
#endif

    ST7565_command(CMD_SET_COLUMN_LOWER | ((col+ST7565_STARTBYTES) & 0xf));
    osDelay(1);
    ST7565_command(CMD_SET_COLUMN_UPPER | (((col+ST7565_STARTBYTES) >> 4) & 0x0F));
    osDelay(1);
    ST7565_command(CMD_RMW);
    osDelay(1);
    
    for(; col < maxcol; col++) {
      ST7565_data(st7565_buffer[(128 * p) + col]);
    }
  }

#ifdef enablePartialUpdate
  xUpdateMin = LCDWIDTH;// - 1;
  xUpdateMax = 0;
  yUpdateMin = LCDHEIGHT;//-1;
  yUpdateMax = 0;
#endif
}

// clear everything
void ST7565_clear(void) {
  memset(st7565_buffer, 0, 1024);
  ST7565_updateBoundingBox(0, 0, LCDWIDTH - 1, LCDHEIGHT - 1);
}

// this doesnt touch the buffer, just clears the display RAM - might be handy
void ST7565_clear_display(void){
  uint8_t p, c;
  
  for(p = 0; p < 8; p++) {
		ST7565_command(CMD_SET_PAGE | p);
    for(c = 0; c < 128; c++) {
      ST7565_command(CMD_SET_COLUMN_LOWER | (c & 0xf));
      ST7565_command(CMD_SET_COLUMN_UPPER | ((c >> 4) & 0xf));
      
      ST7565_data(0x0);
    }
  }
}
